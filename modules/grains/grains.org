#   ________             .__               
#  /  _____/___________  |__| ____   ______
# /   \  __\_  __ \__  \ |  |/    \ /  ___/
# \    \_\  \  | \// __ \|  |   |  \\___ \ 
#  \______  /__|  (____  /__|___|  /____  >
#         \/           \/        \/     \/

DSP Module for Aleph Sound Computer

With this program loaded onto the blackfin dsp, an aleph can quickly
transform between any of the following digital music devices:

- dual-voice pitchshifter effect
- chorus/flanger effect
- rudimentary Karplus-Strong resonator
- live performance sampler with independent speed & pitch
- echo effect
- pitch-tracking re-synthesizer for monophonic audio input
- pitch/volume tremolo
- ring Modulator effect
- FM-synth-like effect for arbitrary audio input

A great number of permutations and combinations of these basic
functions may be realised through careful manipulation of grains' 84
control & patch parameters from BEES.

The remainder of this document is given over to a detailed description
of grains' parameters.

* CV Params
** Source-cv1
   Choose source for CV out 1 from patch matrix
** Source-cv2
   Choose source for CV out 2 from patch matrix
** Source-cv3
   Choose source for CV out 3 from patch matrix
** Source-cv4
   Choose source for CV out 4 from patch matrix
* ADC mix params
  ADCs 1 & 2 are hard-wired to mixer channels 1 & 2, whereas mixer
  channels 3 & 4 select their source from the patch matrix.
** fader-i[n]
   Stereo fader from mixer chan n to DACS 1&2
** pan-i[n]
   Stereo pan from mixer chan n between DACS 1&2
** effect-i[n]
   Send from mixer chan n to effect bus
** aux0-i[n]
   Fader from mixer chan n to DAC3
** aux1-i[n]
   Fader from mixer chan n to DAC4
** source-i[n]
   Choose mixer channel input from patch matrix
* Grain Mix params
** source-g[m]
   Choose grain input from patch matrix
** fader-g[m]
   Stereo fader from grain m to DACS 1&2
** pan-g[m]
   Stereo pan from grain m between DACS 1&2
** effect-g[m]
   Send from grain m to effect bus
** aux0-g[m]
   Fader from grain m to DAC3
** aux1-g[m]
   Fader from grain m to DAC4
** phase-g[m]
   phase of grain m (+ve or -ve)
** lpf-g[m]
   Cutoff frequency (in Hz) for grain output (low-pass filter)
* Grain Modulation Params
** FM-source-g[m]
   Choose a signal from patch matrix to modulate scrubPitch of grain.
   If scrubbing disabled, FM becomes PM (modulating read position
   relative to echotap).
** FM-level-g[m]
   Set depth of modulation induced by FM-source
** AM-source
   Choose a signal from patch matrix to modulate amplitude of grain
   output.
** AM-level-g[m]
   Pan between modulated and unmodulated grain output.
* Grain Scrub params
** scrubEnabfle-g[m]
   enable scrubbing behaviour for this grain (pitch control
   independent of echo speed).
** scrubPitch-g[m]
   speed of scrubber read tap in subsamples (1/256 sample) - bees
   displays 1.000 at speed = 1 sample/sample
** scrubLength-g[m]
   length of scrubber read distance from echo readhead before cross-fading.
   This is expressed as a ratio to the scrubberFadeLength
** scrubPitchDetection-g[m]
   When this is enabled, scrublength 'snaps' to an even multiple of
   grain input signal.  Zero crossing pitch detection with adaptive
   filter.
* Grain Echo params
** echoFadeLength-g[m]
   length for scrubber crossfades.  Again expressed as a ratio to echomax-echomin
** echoTime-g[m]
   allows bees to force read head to a point, e.g:
   - set echo time for simple echo fx
   - trigger one-shot (stalled) sample for pre-recorded audio
** echoSpeed-g[m]
   For canonical realtime FX like this guy should be 1, so the
   echo-tap stays in sync with write head. When a sample is loaded
   into the fifo this guy replays the sample.  See echoEdgeBehaviour
   for playback modes.  If you're feeling crazy unglue the echo tap
   from writing head while write head runs by setting this value != 1
** echoEdgeBehaviour-g[m]
   set this to 0 or 1 to control does echo-tap head stall, or wrap at
   echo boundary respectively?  Also possible to retrigger one-shot samples by
   resending 0.
** echoMin-g[m]
   echo boundary nearest to write-head
** echoMax-g[m]
   echo boundary furthest from write-head
** writeEnable-g[m]
   Choose between constantly writing new data into echotap or simply
   re-playing already-recorded audio in the underlying buffer.
* Grain Pitch & Amplitude Analysis / Tracking
** envAttack-g[m]
   Attack of the envelope detector - this control is a little rough
   round the edges but it kinda works.  Broadly speaking smaller
   number -> slower attack.
** trackingEnv-g[m]
   Multiply PitchTracking Oscillator by grain envelope befre sending
   it to patch matrix.
** trackingPitch-g[m]
   Frequency Offset factor for pitchTracking oscillator/synth
* Grains Utilities
** LFO-speed
   Speed of LFO (smaller number = slower oscillation down to very slow
   oscillations.  LFO signal is output to patch matrix.
** LFO-shape
   Blend between a triangular LFO shape (0) and sinusoid shape (max)
** noiseBurst
   Trigger a noise burst impulse into patch matrix
** noiseBurstDecay
   How quickly does noise burst impulse decay (small number = long burst)
** static-CV1
   Set a DC value from BEES on static-CV1 slot in patch matrix
** static-CV2
   Set a DC value from BEES on static-CV2 slot in patch matrix
* Patch Matrix
  The astute reader will notice a number of cryptic references to a
  so-called 'patch matrix'.  This allows the program to be internally
  re-wired like patching a modular synthesizer.  Patch index denotes
  an output & each patch-matrix-enabled input may choose one and only
  one source from the patch matrix.
** Patch matrix Cheatsheet:

0. Effect Bus
1. ADC 1
2. ADC 2
3. ADC 3
4. ADC 4
5. grain1 output
6. grain2 output
7. grain1 echoTap pitchtrack oscillator
8. grain2 echoTap pitchtrack oscillator
9. grain1 echoTap envelope
10. grain2 echoTap envelope
11. LFO
12. noise burst
13. static-CV1
14. static-CV2

* What is a grain?
  A grain consists a buffer, a write head running at 1x, an
  'echoTap' & a 'scrubTap'.

    The write head is the same as the one in lines - I set the
    underlying buffer to be very long.  The echoTap is like a lines
    read head but it can run at non-integer speeds, it's time coord is
    relative to the write head (wrapping round the underlying buffer
    is hidden) but playback speed is relative to the underlying buffer
    (though think there's a subtle bug in this respect with current
    release).  The scrubTap is kind of similar to an echoTap but it's
    time coord is relative to the echoTap, and it's time coord is much
    finer grained than the echoTap.

* Bugs!?
  Please send bug reports and/or patches to sasquatch@rickvenn.com or
  github.com/rick-monster/aleph.
